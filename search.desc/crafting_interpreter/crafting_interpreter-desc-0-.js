searchState.loadedDescShard("crafting_interpreter", 0, "Returns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n0での除算を試みた場合のエラー。\n…\n…\n型変換が無効な場合のエラー。\n入出力エラー。\n…\n条件式がブール値でない場合のエラー。\nパースエラー。\n関数外で <code>return</code> 文を使用した場合のエラー。\n実行時に発生するエラー。\n未定義の変数を参照した場合のエラー。\n…\n未終了の文字列リテラルのエラー。\n…\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n…\n環境に新しい変数を定義\nステートメントのリストを評価します。\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n…\n実行結果を取得します。\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n…\n<code>Evaluator</code> …\n新しい環境を作成\n指定された環境を囲む新しい環境を作成\n…\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n新しい <code>Parser</code> インスタンスを作成します。\n…\n…\n<code>Visitor</code> …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n…\n変数の代入を訪問します。\n変数の代入。\nバイナリ式（例: …\nバイナリ式（例: 加算や減算）。\nブロック文を訪問します。\nブロック文。\n関数呼び出しを訪問します。\n関数呼び出し。\nクラス宣言を訪問します。\nクラス宣言。\n式文（式だけの文）を訪問します。\n式文。\n<code>for</code> 文を訪問します。\n<code>for</code> 文。\n関数宣言を訪問します。\n関数宣言。\n…\nオブジェクトのプロパティ取得。\n…\nグループ化された式（括弧内の式）。\n<code>if</code> 文を訪問します。\n<code>if</code> 文。\nリテラル値（例: …\nリテラル値（例: 数値や文字列）。\n<code>print</code> 文を訪問します。\n<code>print</code> 文。\n<code>return</code> 文を訪問します。\n<code>return</code> 文。\n…\nオブジェクトのプロパティ設定。\n<code>super</code> キーワードを訪問します。\n<code>super</code> キーワード。\n<code>this</code> キーワードを訪問します。\n<code>this</code> キーワード。\n単項演算子（例: <code>-</code> や <code>!</code>）を訪問します。\n単項演算子（例: <code>-</code> や <code>!</code>）。\n変数宣言文を訪問します。\n変数宣言文。\n変数参照を訪問します。\n変数参照。\n<code>while</code> 文を訪問します。\n<code>while</code> 文。\n字句解析器（Scanner）\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n新しい <code>Scanner</code> の生成\nトークンのスキャン処理\n<code>Token</code> は、Lox …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nトークンの元の文字列表現です。\n…\nトークンに関連付けられたリテラル値（例: …\n…\nトークンの種類を示します（例: Identifier, …\n<code>and</code> キーワード\n<code>!</code> トークン\n<code>!=</code> トークン\nブール型のリテラル値\n<code>class</code> キーワード\n<code>,</code> トークン\n<code>.</code> トークン\n<code>else</code> キーワード\nファイルの終端を示すトークン\n<code>=</code> トークン\n<code>==</code> トークン\n<code>false</code> キーワード\n<code>for</code> キーワード\n<code>fun</code> キーワード\nユーザー定義関数\n<code>&gt;</code> トークン\n<code>&gt;=</code> トークン\n識別子トークン\n<code>if</code> キーワード\n<code>{</code> トークン\n<code>(</code> トークン\n<code>&lt;</code> トークン\n<code>&lt;=</code> トークン\n<code>LiteralValue</code> は、Lox …\n<code>-</code> トークン\n<code>nil</code> キーワード\n<code>nil</code> を表すリテラル値\n数値リテラルトークン\n数値型のリテラル値\n<code>or</code> キーワード\n<code>%</code> トークン\n<code>+</code> トークン\n<code>print</code> キーワード\n<code>return</code> キーワード\n<code>return</code> 文による返り値\n<code>}</code> トークン\n<code>)</code> トークン\n<code>;</code> トークン\n<code>/</code> トークン\n<code>*</code> トークン\n文字列型のリテラル値\n文字列リテラルトークン\n<code>super</code> キーワード\n<code>this</code> キーワード\n<code>TokenType</code> は、Lox …\n<code>true</code> キーワード\n<code>var</code> キーワード\n<code>while</code> キーワード\n数値リテラルを取得します。\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n関数の本体\n関数の名前\n関数の引数リスト\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n関数呼び出し時の情報を管理する\n関数の情報を保持する構造体\nグローバル変数を管理する\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.")